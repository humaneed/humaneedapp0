<!doctype html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>HUMANEED â€” Engine Demo</title>
  <style>
    :root{
      --metal-void:#0a0b0d; --metal-dark:#111315; --metal-base:#17191c; --metal-light:#1e2024;
      --teal:#2dd4bf; --amber:#fbbf24; --green:#34d399;
      --text:#e2e6e4; --muted:#6e8280; --dim:#454a52;
      --hair:rgba(45,212,191,0.12);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--metal-void);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:520px;margin:0 auto;min-height:100%}
    header{
      position:sticky;top:0;z-index:10;
      background:linear-gradient(180deg,var(--metal-base),var(--metal-dark));
      border-bottom:1px solid var(--hair);
      padding:14px 14px 12px;
      display:flex;justify-content:space-between;align-items:center;
      box-shadow:0 10px 40px rgba(0,0,0,.45);
    }
    .brand{letter-spacing:4px;font-weight:300;text-transform:uppercase;font-size:13px;border:0;background:none;color:var(--text);cursor:pointer}
    .actions{display:flex;gap:10px}
    .icon{width:36px;height:36px;border-radius:10px;border:1px solid var(--hair);background:linear-gradient(135deg,var(--metal-base),var(--metal-dark));color:var(--text);cursor:pointer}
    main{padding:16px 14px 40px}
    .eyebrow{font-size:11px;letter-spacing:4px;font-weight:800;text-transform:uppercase;color:var(--muted)}
    .sub{font-size:10px;letter-spacing:2px;text-transform:uppercase;color:var(--dim);margin-top:4px}
    .card{
      margin-top:14px;
      background:var(--metal-dark);
      border:1px solid rgba(45,212,191,.22);
      border-radius:14px;
      padding:16px;
      box-shadow:inset 0 1px 0 rgba(255,255,255,.05), 0 18px 42px rgba(0,0,0,.5);
    }
    .labelrow{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:10px}
    .label{
      display:inline-flex;gap:8px;align-items:center;
      font-size:10px;font-weight:900;letter-spacing:2px;text-transform:uppercase;
      color:var(--muted);
      border:1px solid rgba(45,212,191,.20);
      background:rgba(45,212,191,.06);
      padding:6px 10px;border-radius:8px;
    }
    .chip{
      font-size:10px;font-weight:900;letter-spacing:1.2px;text-transform:uppercase;
      color:rgba(45,212,191,1);
      border:1px solid rgba(45,212,191,.22);
      background:rgba(45,212,191,.05);
      padding:6px 10px;border-radius:999px;
    }
    .title{display:flex;gap:10px;align-items:baseline;font-weight:900;font-size:18px;letter-spacing:-.01em;margin:4px 0 10px}
    .mini{font-size:10px;font-weight:900;letter-spacing:2px;text-transform:uppercase;color:var(--dim);margin:10px 0 8px}
    .desc{color:var(--muted);font-size:13px;line-height:1.6}
    ul{margin:10px 0 0;padding-left:18px;color:var(--muted);font-size:13px;line-height:1.7}
    li{margin:3px 0}
    .alt{margin-top:12px;border-top:1px solid rgba(255,255,255,.06);padding-top:10px;color:var(--dim);font-style:italic;font-size:12px}
    .btn{
      width:100%;margin-top:12px;padding:13px 14px;border:0;border-radius:999px;cursor:pointer;
      font-weight:900;font-size:12px;letter-spacing:1.5px;text-transform:uppercase;color:#0a0b0d;
      background:linear-gradient(180deg,#d4a055,#c49040);
      box-shadow:0 10px 26px rgba(212,160,32,.28);
    }
    .btn2{
      width:100%;margin-top:10px;padding:12px 14px;border-radius:999px;cursor:pointer;
      border:1px solid rgba(255,255,255,.10);
      background:linear-gradient(180deg,var(--metal-light),var(--metal-base));
      color:var(--text);
      font-weight:900;font-size:12px;letter-spacing:1.5px;text-transform:uppercase;
    }
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:14px}
    .gcard{
      border:1px solid rgba(255,255,255,.08);
      background:linear-gradient(145deg,rgba(23,25,28,.92),rgba(17,19,21,.98));
      border-radius:14px;padding:12px;
      box-shadow:inset 0 1px 0 rgba(255,255,255,.04),0 14px 32px rgba(0,0,0,.45);
    }
    .ghead{display:flex;justify-content:space-between;align-items:baseline;margin-bottom:10px;gap:10px}
    .gname{display:flex;gap:8px;align-items:center;font-weight:900;font-size:12px}
    .gval{font-weight:900;font-size:12px;color:rgba(226,230,228,.92)}
    .bar{height:6px;border-radius:999px;background:rgba(255,255,255,.07);overflow:hidden}
    .fill{height:100%;border-radius:999px}
    .foot{display:flex;justify-content:space-between;margin-top:8px;font-size:10px;letter-spacing:.9px;text-transform:uppercase;color:var(--dim)}
    .warn{color:rgba(251,191,36,.95)}
    .pulse{animation:pulse 2.8s ease-in-out infinite;border-color:rgba(251,191,36,.35)}
    @keyframes pulse{0%,100%{transform:translateY(0)}50%{transform:translateY(-1px)}}

    .why{margin-top:10px;color:var(--muted);font-size:13px;line-height:1.6}
    .divider{height:1px;background:rgba(255,255,255,.06);margin:12px 0}
    .row{display:flex;gap:10px}
    .small{flex:1}
    .input{
      width:100%;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.22);color:var(--text);outline:none;
    }
    .hint{font-size:11px;color:var(--dim);margin-top:6px}
    .sheet{
      position:fixed;inset:0;background:rgba(0,0,0,.72);
      display:none;align-items:flex-end;justify-content:center;z-index:99;
      backdrop-filter:blur(10px);
    }
    .sheet.open{display:flex}
    .panel{
      width:100%;max-width:520px;
      background:linear-gradient(180deg,var(--metal-base),var(--metal-dark));
      border-top:1px solid rgba(45,212,191,.20);
      border-radius:24px 24px 0 0;
      padding:14px 14px 18px;
      box-shadow:0 -18px 70px rgba(0,0,0,.75);
      transform:translateY(0);
    }
    .handle{width:44px;height:4px;border-radius:999px;background:rgba(255,255,255,.15);margin:4px auto 12px}
    .slabel{font-size:10px;font-weight:900;letter-spacing:3px;text-transform:uppercase;color:rgba(45,212,191,1);margin-bottom:10px}
    .qrow{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .qbtn{
      border:1px solid rgba(255,255,255,.10);
      background:linear-gradient(180deg,var(--metal-light),var(--metal-base));
      border-radius:14px;padding:12px;cursor:pointer;color:var(--text);
      font-weight:900;font-size:12px;letter-spacing:.6px;
    }
    .qbtn:active{transform:translateY(1px)}
    @media (max-width:420px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <button class="brand" id="homeBtn">HUMANEED</button>
    <div class="actions">
      <button class="icon" id="langBtn" title="Language"><span id="langBadge" style="font-weight:900;color:var(--teal);font-size:11px">DE</span></button>
      <button class="icon" id="resetBtn" title="Reset">â†º</button>
      <button class="icon" id="whyBtnTop" title="Why">?</button>
    </div>
  </header>

  <main id="app"></main>
</div>

<!-- Qualia sheet -->
<div class="sheet" id="sheet">
  <div class="panel" role="dialog" aria-label="Qualia feedback">
    <div class="handle"></div>
    <div class="slabel" id="sheetTitle">RESONANZ</div>
    <div class="desc" id="sheetPrompt">Wie hat sich das angefÃ¼hlt?</div>
    <div class="divider"></div>
    <div class="qrow">
      <button class="qbtn" data-q="3">ðŸ˜Œ Gut</button>
      <button class="qbtn" data-q="2">ðŸ™‚ Okay</button>
      <button class="qbtn" data-q="1">ðŸ˜• Schwer</button>
      <button class="qbtn" data-q="0">â›” Abgebrochen</button>
    </div>
    <button class="btn2" id="closeSheet">SchlieÃŸen</button>
  </div>
</div>

<script>
(() => {
  // =========================
  // HUMANEED ENGINE (HTML)
  // =========================
  const STORE_KEY = "humaneed_engine_v1";

  // --- Time/Decay
  const BASELINE = 50;
  const DECAY_HOURS = 8;

  // --- Core signals + 6 dimensions (tiers)
  const CORE_KEYS = ["energy","mood","focus","connection"];
  const DIM_KEYS = ["biology","emotion","social","cognition","competence","meaning"];
  const DIM_TIER = { biology:0, emotion:1, social:2, cognition:3, competence:4, meaning:5 };

  const CORE_META = {
    energy:{de:"Energie",en:"Energy",icon:"âš¡",color:"rgba(251,191,36,1)"},
    mood:{de:"Stimmung",en:"Mood",icon:"ðŸŒ¡ï¸",color:"rgba(226,230,228,0.85)"},
    focus:{de:"Fokus",en:"Focus",icon:"ðŸŽ¯",color:"rgba(45,212,191,1)"},
    connection:{de:"Verbindung",en:"Connection",icon:"ðŸ¤",color:"rgba(52,211,153,1)"}
  };

  const I18N = {
    de:{
      headline:"TODAY'S MEANINGFUL STEP",
      sub:"Biological Attunement Navigation",
      primary:"PRIMARY ACTION CLUSTER",
      protocol:"EXECUTION PROTOCOL",
      alt:"ALT OPTION:",
      complete:"MARK AS COMPLETE",
      why:"WHY THIS TODAY?",
      signals:"SIGNALS",
      moment:"MOMENT READOUT",
      diagnosis:"Diagnose",
      signal:"Signal",
      baseline:"baseline",
      critical:"critical",
      qualiaTitle:"RESONANZ",
      qualiaPrompt:"Wie hat sich das angefÃ¼hlt?",
      close:"SchlieÃŸen",
      resetAsk:"Wirklich alles zurÃ¼cksetzen?"
    },
    en:{
      headline:"TODAY'S MEANINGFUL STEP",
      sub:"Biological Attunement Navigation",
      primary:"PRIMARY ACTION CLUSTER",
      protocol:"EXECUTION PROTOCOL",
      alt:"ALT OPTION:",
      complete:"MARK AS COMPLETE",
      why:"WHY THIS TODAY?",
      signals:"SIGNALS",
      moment:"MOMENT READOUT",
      diagnosis:"Diagnosis",
      signal:"Signal",
      baseline:"baseline",
      critical:"critical",
      qualiaTitle:"RESONANCE",
      qualiaPrompt:"How did that feel?",
      close:"Close",
      resetAsk:"Reset everything?"
    }
  };

  // --- Skill Library (extend as you like)
  // Effects: expected deltas to core + dimensions (small numbers)
  // requirements: minimum base stability for tiered skills (synergy gating)
  const SKILLS = [
    {
      id:"bio_water",
      tier:"biology",
      mins:2, emoji:"ðŸ’§",
      name:{de:"Wasser + Salz", en:"Water + pinch of salt"},
      desc:{de:"Kurz stabilisieren, bevor du Leistung erwartest.", en:"Stabilize first before demanding performance."},
      protocol:{de:["200â€“300ml Wasser","Optional: kleine Prise Salz","60 Sekunden ruhig atmen"], en:["200â€“300ml water","Optional: pinch of salt","60 seconds calm breathing"]},
      alt:{de:"5x tiefes Einatmen am Fenster.", en:"5 deep breaths by a window."},
      effects:{
        core:{energy:+3, mood:+1, focus:+1, connection:0},
        dims:{biology:+4}
      },
      tags:["hydration","reset"],
      safety:{ note:{de:"Kein medizinischer Rat.", en:"Not medical advice."} }
    },
    {
      id:"bio_walk10",
      tier:"biology",
      mins:10, emoji:"ðŸš¶",
      name:{de:"10 Min Spaziergang", en:"10 min walk"},
      desc:{de:"Bewegung senkt Stresslast und verbessert Regulation.", en:"Movement reduces stress load and improves regulation."},
      protocol:{de:["Schuhe an","10 Min steady","Wasser danach"], en:["Shoes on","10 min steady","Water after"]},
      alt:{de:"3 Min 4-7-8 Atmung.", en:"3 min 4-7-8 breathing."},
      effects:{ core:{energy:-1, mood:+2, focus:+2, connection:0}, dims:{biology:+3, emotion:+1} },
      tags:["movement","regulation"]
    },
    {
      id:"emo_breath3",
      tier:"emotion",
      mins:3, emoji:"ðŸŒ¬ï¸",
      name:{de:"3 Min Downshift", en:"3 min downshift"},
      desc:{de:"Parasympathischer Reset: Spannung runter.", en:"Parasympathetic reset: reduce tension."},
      protocol:{de:["Nase ein 4","halten 2","aus 6","wiederholen"], en:["In 4","hold 2","out 6","repeat"]},
      alt:{de:"30 Sek Schulter lÃ¶sen.", en:"30 sec shoulder release."},
      effects:{ core:{energy:+1, mood:+3, focus:+1, connection:0}, dims:{emotion:+4} },
      tags:["calm","breath"]
    },
    {
      id:"soc_call5",
      tier:"social",
      mins:5, emoji:"ðŸ“ž",
      name:{de:"5 Min Kontakt", en:"5 min connection"},
      desc:{de:"Kurzer Call/Text: Verbindung stabilisiert Systeme.", en:"A quick call/text stabilizes the system."},
      protocol:{de:["1 Person wÃ¤hlen","5 Min ehrlicher Check-in","kurz bedanken"], en:["Choose 1 person","5 min honest check-in","thank them"]},
      alt:{de:"Voice-Note senden.", en:"Send a voice note."},
      effects:{ core:{energy:0, mood:+2, focus:+1, connection:+4}, dims:{social:+5, emotion:+1} },
      tags:["connection"]
    },
    {
      id:"cog_deep45",
      tier:"cognition",
      mins:45, emoji:"ðŸŽ¯",
      name:{de:"Deep Work: Single Task", en:"Deep Work: single task"},
      desc:{de:"Ein Fokusblock, ohne Tabs, ohne Split.", en:"One focused block: no tabs, no split."},
      protocol:{de:["Desk clear","Phone silent","Timer 45","nur 1 Task"], en:["Clear desk","Silence phone","Timer 45","single task only"]},
      alt:{de:"15 Min Mindful Walk.", en:"15 min mindful walk."},
      effects:{ core:{energy:-4, mood:+1, focus:+5, connection:0}, dims:{cognition:+6} },
      tags:["focus","work"],
      requirements:{ minBiology:45 } // synergy gating
    },
    {
      id:"mea_reflect7",
      tier:"meaning",
      mins:7, emoji:"ðŸ§­",
      name:{de:"7 Min Richtung", en:"7 min direction"},
      desc:{de:"Kurzschrift: Was zÃ¤hlt heute wirklich?", en:"Short writing: what truly matters today?" },
      protocol:{de:["1 Satz: Ziel","1 Satz: warum","1 nÃ¤chster Schritt"], en:["1 sentence: goal","1: why","1 next step"]},
      alt:{de:"3 Min Notizen.", en:"3 min notes."},
      effects:{ core:{energy:0, mood:+2, focus:+2, connection:0}, dims:{meaning:+6, cognition:+1} },
      tags:["meaning"],
      requirements:{ minBiology:50, minEmotion:45 }
    }
  ];

  // --- Engine knobs (calm, non-gamified)
  const ENGINE = {
    // how much we care about deficits per dimension and signal
    deficitWeight: 1.0,
    // penalty for doing high-tier when base is low
    synergyPenalty: 0.65,
    // discourage repeating same skill too soon
    cooldownHours: 12,
    // exploration vs exploitation for learning
    exploration: 0.20, // 0..1 (higher = more variety)
    // how strongly qualia shifts personal preference
    qualiaLearningRate: 0.22
  };

  // =========================
  // State (Event Log)
  // =========================
  function now(){ return Date.now(); }
  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  function load(){
    try{ return JSON.parse(localStorage.getItem(STORE_KEY)||"null"); }catch{ return null; }
  }
  function save(s){
    localStorage.setItem(STORE_KEY, JSON.stringify(s));
  }

  function initialState(){
    const isDE = (navigator.language||"en").toLowerCase().startsWith("de");
    return {
      lang: isDE ? "de" : "en",
      // canonical current values (derived from events + decay)
      core: { energy:62, mood:56, focus:66, connection:52 },
      dims: { biology:70, emotion:60, social:56, cognition:72, competence:60, meaning:52 },
      coreUpdatedAt: now(),
      dimsUpdatedAt: now(),

      // learning per skill id: {mean, n, lastQualia}
      skillModel: {},

      // event log
      events: [
        // {type:"complete"|"qualia"|"checkin", ts, skillId?, payload?}
      ],

      // current recommendation cache
      rec: { primary:null, alt:null, why:null, computedAt:0 }
    };
  }

  let state = load() || initialState();
  state = migrateState(state);
  save(state);

  function migrateState(s){
    // gentle forward-compat
    s.events ||= [];
    s.skillModel ||= {};
    s.core ||= {energy:50,mood:50,focus:50,connection:50};
    s.dims ||= {biology:50,emotion:50,social:50,cognition:50,competence:50,meaning:50};
    s.coreUpdatedAt ||= now();
    s.dimsUpdatedAt ||= now();
    s.rec ||= {primary:null,alt:null,why:null,computedAt:0};
    return s;
  }

  // =========================
  // Decay towards baseline
  // =========================
  function applyDecayToCore(){
    const tNow = now();
    const hours = Math.max(0, (tNow - state.coreUpdatedAt) / (1000*60*60));
    const t = clamp(hours / DECAY_HOURS, 0, 1);
    const next = {...state.core};
    for(const k of CORE_KEYS){
      next[k] = Math.round(lerp(state.core[k], BASELINE, t));
    }
    const changed = CORE_KEYS.some(k => next[k] !== state.core[k]);
    if(changed){ state.core = next; }
    // do NOT move coreUpdatedAt; it is the anchor of decay from last real update
  }

  function applyDecayToDims(){
    const tNow = now();
    const hours = Math.max(0, (tNow - state.dimsUpdatedAt) / (1000*60*60));
    const t = clamp(hours / DECAY_HOURS, 0, 1);
    const next = {...state.dims};
    for(const k of DIM_KEYS){
      next[k] = Math.round(lerp(state.dims[k], BASELINE, t));
    }
    const changed = DIM_KEYS.some(k => next[k] !== state.dims[k]);
    if(changed){ state.dims = next; }
  }

  // =========================
  // Moment inference (transparent)
  // =========================
  function inferMoment(){
    const lastComplete = [...state.events].reverse().find(e => e.type==="complete");
    const hoursSince = lastComplete ? (now()-lastComplete.ts)/(1000*60*60) : 999;

    const c = state.core;
    const low = (v)=>v<38;
    let label = state.lang==="de" ? "Stabil" : "Stable";
    let reason = state.lang==="de" ? "Signale im Normbereich" : "Signals within normal range";

    if(hoursSince >= 14){
      label = state.lang==="de" ? "Neblig" : "Foggy";
      reason = state.lang==="de"
        ? `${Math.round(hoursSince)}h ohne AktivitÃ¤t (Long Gap)`
        : `${Math.round(hoursSince)}h without activity (Long gap)`;
    }
    if(low(c.energy)){ label = state.lang==="de" ? "ErschÃ¶pft" : "Drained"; reason = state.lang==="de" ? "Energie kritisch" : "Energy critical"; }
    else if(low(c.connection)){ label = state.lang==="de" ? "Getrennt" : "Disconnected"; reason = state.lang==="de" ? "Verbindung niedrig" : "Connection low"; }
    else if(low(c.focus)){ label = state.lang==="de" ? "Fragmentiert" : "Fragmented"; reason = state.lang==="de" ? "Fokus niedrig" : "Focus low"; }
    else if(low(c.mood)){ label = state.lang==="de" ? "GedÃ¤mpft" : "Muted"; reason = state.lang==="de" ? "Stimmung niedrig" : "Mood low"; }

    return { label, reason };
  }

  // =========================
  // Learning model (Qualia)
  // =========================
  // We keep a per-skill preference mean in [-1..+1], initialized at 0.
  // Qualia input q: 0..3 -> map to [-1..+1] => -1, -0.33, +0.33, +1
  function qualiaToScore(q){
    const map = {0:-1,1:-0.33,2:0.33,3:1};
    return map[q] ?? 0;
  }

  function updateSkillModel(skillId, q){
    const x = qualiaToScore(q);
    const m = state.skillModel[skillId] || { mean:0, n:0, lastQualia:null };
    const lr = ENGINE.qualiaLearningRate;
    // exponential moving average + count
    const nextMean = (m.n===0) ? x : (1-lr)*m.mean + lr*x;
    state.skillModel[skillId] = { mean: clamp(nextMean,-1,1), n: m.n+1, lastQualia:q };
  }

  // =========================
  // Synergy gating
  // =========================
  function synergyMultiplier(skill){
    // If higher tier and base dims low -> penalize
    const tier = DIM_TIER[skill.tier];
    if(tier <= 0) return 1;

    // base dims: biology is foundation, then emotion, then social
    const bio = state.dims.biology;
    const emo = state.dims.emotion;

    // hard-ish gate if required minimum not met
    const req = skill.requirements || {};
    if(req.minBiology != null && bio < req.minBiology) return 0.25;
    if(req.minEmotion != null && emo < req.minEmotion) return 0.35;

    // soft penalty: if biology low and tier high
    const basePressure = clamp((50 - bio)/50, 0, 1); // 0..1
    const tierFactor = clamp(tier/5, 0, 1); // 0..1
    const penalty = 1 - ENGINE.synergyPenalty * basePressure * tierFactor;
    return clamp(penalty, 0.25, 1);
  }

  // =========================
  // Cooldown / anti-repeat
  // =========================
  function cooldownPenalty(skillId){
    const last = [...state.events].reverse().find(e => e.type==="complete" && e.skillId===skillId);
    if(!last) return 1;
    const hours = (now()-last.ts)/(1000*60*60);
    if(hours >= ENGINE.cooldownHours) return 1;
    // penalize recent repeats
    const t = clamp(hours/ENGINE.cooldownHours, 0, 1);
    return 0.4 + 0.6*t; // from 0.4 up to 1
  }

  // =========================
  // Need estimation (deficits)
  // =========================
  function deficit(v){ return clamp((BASELINE - v)/50, 0, 1); } // 0..1 below baseline
  function surplus(v){ return clamp((v - BASELINE)/50, 0, 1); }

  function computeNeeds(){
    // combine core deficits and dimension deficits
    const c = state.core, d = state.dims;

    const needs = {
      biology: deficit(d.biology) + deficit(c.energy)*0.8,
      emotion: deficit(d.emotion) + deficit(c.mood)*0.8,
      social: deficit(d.social) + deficit(c.connection)*0.8,
      cognition: deficit(d.cognition) + deficit(c.focus)*0.8,
      competence: deficit(d.competence),
      meaning: deficit(d.meaning)
    };

    // normalize-ish
    for(const k of Object.keys(needs)){
      needs[k] = clamp(needs[k], 0, 2);
    }
    return needs;
  }

  // =========================
  // Score a skill (objective + personal + constraints)
  // =========================
  function scoreSkill(skill, needs){
    // 1) match needs: if skill improves a dimension with high deficit, good
    let needScore = 0;

    // Dimension impact
    for(const [k, delta] of Object.entries(skill.effects.dims || {})){
      if(delta > 0) needScore += needs[k] * (delta/6);
    }

    // Core impact (prefer raising deficits, avoid draining already-low energy)
    for(const [k, delta] of Object.entries(skill.effects.core || {})){
      if(delta > 0) needScore += deficit(state.core[k]) * (delta/6);
      if(delta < 0) needScore -= deficit(state.core[k]) * (Math.abs(delta)/6);
    }

    needScore *= ENGINE.deficitWeight;

    // 2) personal learning preference (qualia mean in [-1..1] mapped to 0.7..1.3)
    const model = state.skillModel[skill.id] || {mean:0,n:0};
    const personal = 1 + (model.mean * 0.25); // subtle
    const explore = ENGINE.exploration * (1 / Math.sqrt(1 + model.n)); // more explore for less-tried

    // 3) synergy + cooldown
    const syn = synergyMultiplier(skill);
    const cd = cooldownPenalty(skill.id);

    // 4) time cost penalty (very small, but helps choose micro-actions when depleted)
    const timePenalty = 1 - clamp((skill.mins - 10)/60, 0, 0.25); // up to -25%

    // final
    const base = needScore * personal * syn * cd * timePenalty;

    // exploration bonus (variety)
    const final = base + explore * 0.06;

    return { final, breakdown:{needScore, personal, syn, cd, timePenalty, explore, mean:model.mean, n:model.n} };
  }

  // =========================
  // Pick recommendation (primary + alternative)
  // =========================
  function pickRecommendation(){
    applyDecayToCore();
    applyDecayToDims();

    const needs = computeNeeds();
    const scored = SKILLS.map(s => {
      const r = scoreSkill(s, needs);
      return { skill:s, score:r.final, breakdown:r.breakdown, needs };
    }).sort((a,b)=>b.score-a.score);

    const primary = scored[0] || null;
    // alt: pick next different tier if possible
    let alt = null;
    if(primary){
      alt = scored.find(x => x.skill.id !== primary.skill.id && x.skill.tier !== primary.skill.tier) || scored[1] || null;
    }

    const why = buildWhy(primary, alt, scored.slice(0,5));
    state.rec = { primary: primary?.skill?.id || null, alt: alt?.skill?.id || null, why, computedAt: now() };
    save(state);

    return { primary, alt, why };
  }

  // =========================
  // Explainability (â€œWhy this today?â€)
  // =========================
  function topNeed(needs){
    return Object.entries(needs).sort((a,b)=>b[1]-a[1])[0];
  }

  function buildWhy(primary, alt, topList){
    const L = I18N[state.lang];
    const m = inferMoment();
    const needs = primary?.needs || computeNeeds();
    const [needKey, needVal] = topNeed(needs);

    // short, instrument-like trace
    const parts = [];
    parts.push(`${L.moment}: ${m.label}`);
    parts.push(`${L.signal}: ${m.reason}`);

    // synergy note if applied
    if(primary){
      const syn = primary.breakdown.syn;
      if(syn < 0.8){
        parts.push(state.lang==="de"
          ? `Synergy: Basis reduziert hÃ¶here Tier-EffektivitÃ¤t (Ã—${syn.toFixed(2)})`
          : `Synergy: base reduces higher-tier effectiveness (Ã—${syn.toFixed(2)})`);
      }
    }

    parts.push(state.lang==="de"
      ? `PrimÃ¤rer Bedarf: ${needKey.toUpperCase()} (${needVal.toFixed(2)})`
      : `Primary need: ${needKey.toUpperCase()} (${needVal.toFixed(2)})`);

    if(primary){
      const b = primary.breakdown;
      parts.push(state.lang==="de"
        ? `Match: need=${b.needScore.toFixed(2)}, personal=${b.personal.toFixed(2)}, cooldown=${b.cd.toFixed(2)}`
        : `Match: need=${b.needScore.toFixed(2)}, personal=${b.personal.toFixed(2)}, cooldown=${b.cd.toFixed(2)}`);
    }

    // keep it short
    return parts.join(" Â· ");
  }

  // =========================
  // Apply completion (effects) + open qualia
  // =========================
  function applySkill(skill){
    // apply effects immediately as "calibration"
    const tNow = now();
    // core
    const nextCore = {...state.core};
    for(const [k, delta] of Object.entries(skill.effects.core || {})){
      nextCore[k] = clamp(nextCore[k] + delta, 0, 100);
    }
    state.core = nextCore;
    state.coreUpdatedAt = tNow; // anchor decay from new state

    // dims
    const nextDims = {...state.dims};
    for(const [k, delta] of Object.entries(skill.effects.dims || {})){
      nextDims[k] = clamp(nextDims[k] + delta, 0, 100);
    }
    state.dims = nextDims;
    state.dimsUpdatedAt = tNow;

    state.events.push({ type:"complete", ts:tNow, skillId: skill.id, payload:{ mins: skill.mins, tier: skill.tier } });
    save(state);
  }

  // =========================
  // UI rendering (minimal)
  // =========================
  const app = document.getElementById("app");
  const langBadge = document.getElementById("langBadge");
  const langBtn = document.getElementById("langBtn");
  const resetBtn = document.getElementById("resetBtn");
  const whyBtnTop = document.getElementById("whyBtnTop");
  const homeBtn = document.getElementById("homeBtn");

  const sheet = document.getElementById("sheet");
  const sheetTitle = document.getElementById("sheetTitle");
  const sheetPrompt = document.getElementById("sheetPrompt");
  const closeSheet = document.getElementById("closeSheet");

  function t(k){ return I18N[state.lang][k] || k; }

  function render(){
    langBadge.textContent = state.lang.toUpperCase();

    const rec = pickRecommendation();
    const primary = rec.primary?.skill || null;
    const alt = rec.alt?.skill || null;
    const why = rec.why;

    const moment = inferMoment();

    // Signals cards
    const signals = CORE_KEYS.map(k => {
      const meta = CORE_META[k];
      const v = state.core[k];
      const critical = v < 35;
      return `
        <div class="gcard ${critical ? "pulse" : ""}">
          <div class="ghead">
            <div class="gname"><span>${meta.icon}</span><span>${state.lang==="de"?meta.de:meta.en}</span></div>
            <div class="gval">${v}%</div>
          </div>
          <div class="bar"><div class="fill" style="width:${v}%;background:${meta.color}"></div></div>
          <div class="foot"><span>${t("baseline")} ${BASELINE}%</span>${critical?`<span class="warn">${t("critical")}</span>`:`<span></span>`}</div>
        </div>
      `;
    }).join("");

    const protocol = primary ? primary.protocol[state.lang].map(x=>`<li>${esc(x)}</li>`).join("") : "";
    const altText = alt ? `${esc(alt.emoji)} ${esc(alt.name[state.lang])} (${alt.mins} ${state.lang==="de"?"Min":"min"})` : "â€”";

    app.innerHTML = `
      <div class="eyebrow">${t("headline")}</div>
      <div class="sub">${t("sub")}</div>

      <div class="card" style="margin-top:12px">
        <div class="labelrow">
          <div class="label">${t("moment")}</div>
          <div class="chip">${t("diagnosis")}: ${esc(moment.label)}</div>
        </div>
        <div class="desc">${t("signal")}: ${esc(moment.reason)}</div>
      </div>

      <div class="card">
        <div class="labelrow">
          <div class="label">${t("signals")}</div>
          <div class="chip">decay ${DECAY_HOURS}h â†’ ${BASELINE}%</div>
        </div>
        <div class="grid">${signals}</div>
      </div>

      <div class="card">
        <div class="labelrow">
          <div class="label">${t("primary")}</div>
          <div class="chip">${primary ? `${primary.mins} ${state.lang==="de"?"Min":"min"}` : "â€”"}</div>
        </div>

        <div class="title">${primary ? `${esc(primary.emoji)} <span>${esc(primary.name[state.lang])}</span>` : "â€”"}</div>
        <div class="mini">${t("protocol")}</div>
        <div class="desc">${primary ? esc(primary.desc[state.lang]) : "â€”"}</div>
        <ul>${protocol}</ul>

        <div class="alt"><b>${t("alt")}</b> ${altText}</div>

        <button class="btn2" id="whyBtn">${t("why")}</button>
        <button class="btn" id="completeBtn">${t("complete")}</button>

        <div class="why" id="whyText" style="display:none">${esc(why)}</div>
      </div>

      <div class="card">
        <div class="label">Engine Debug (Top 5)</div>
        <div class="desc" style="margin-top:6px">${renderTop5(rec.primary, rec.alt)}</div>
      </div>
    `;

    document.getElementById("whyBtn").onclick = () => {
      const el = document.getElementById("whyText");
      el.style.display = (el.style.display==="none") ? "block" : "none";
    };

    document.getElementById("completeBtn").onclick = () => {
      if(!primary) return;
      applySkill(primary);
      openQualia(primary.id);
      render();
    };
  }

  function renderTop5(primaryWrap, altWrap){
    // show scores + multipliers (compact)
    const needs = computeNeeds();
    const scored = SKILLS.map(s => ({ s, r: scoreSkill(s, needs) }))
      .sort((a,b)=>b.r.final-a.r.final)
      .slice(0,5);

    return scored.map(x => {
      const m = state.skillModel[x.s.id] || {mean:0,n:0};
      return `${x.s.emoji} ${esc(x.s.name[state.lang])}: ${x.r.final.toFixed(3)} (synÃ—${x.r.breakdown.syn.toFixed(2)}, cdÃ—${x.r.breakdown.cd.toFixed(2)}, pref=${m.mean.toFixed(2)}/${m.n})`;
    }).join("<br>");
  }

  function esc(s){
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
  }

  // =========================
  // Qualia sheet controls
  // =========================
  let pendingSkillId = null;

  function openQualia(skillId){
    pendingSkillId = skillId;
    sheetTitle.textContent = t("qualiaTitle");
    sheetPrompt.textContent = t("qualiaPrompt");
    closeSheet.textContent = t("close");
    sheet.classList.add("open");
  }

  function closeQualia(){
    sheet.classList.remove("open");
    pendingSkillId = null;
  }

  sheet.addEventListener("click", (e) => { if(e.target === sheet) closeQualia(); });
  closeSheet.onclick = closeQualia;

  sheet.querySelectorAll(".qbtn").forEach(btn => {
    btn.addEventListener("click", () => {
      const q = Number(btn.getAttribute("data-q"));
      if(!pendingSkillId) return;
      // log + learn
      state.events.push({ type:"qualia", ts: now(), skillId: pendingSkillId, payload:{ q } });
      updateSkillModel(pendingSkillId, q);
      save(state);
      closeQualia();
      render();
    });
  });

  // =========================
  // Header actions
  // =========================
  langBtn.onclick = () => { state.lang = (state.lang==="de"?"en":"de"); save(state); render(); };
  whyBtnTop.onclick = () => { // toggle why section
    const el = document.getElementById("whyText");
    if(el) el.style.display = (el.style.display==="none") ? "block" : "none";
  };
  homeBtn.onclick = () => render();

  resetBtn.onclick = () => {
    if(confirm(t("resetAsk"))){
      localStorage.removeItem(STORE_KEY);
      state = initialState();
      save(state);
      render();
    }
  };

  // =========================
  // Passive decay tick (quiet)
  // =========================
  setInterval(() => {
    // only rerender if something actually changes
    const before = JSON.stringify(state.core) + JSON.stringify(state.dims);
    applyDecayToCore();
    applyDecayToDims();
    const after = JSON.stringify(state.core) + JSON.stringify(state.dims);
    if(before !== after){
      save(state);
      render();
    }
  }, 15000);

  // Initial paint
  render();

})();
</script>
</body>
</html>
